"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForkService = exports.ForkCacheService = void 0;
const everscale_inpage_provider_1 = require("everscale-inpage-provider");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const rxjs_1 = require("rxjs");
const utils_1 = require("../../utils");
const stateFetchers_1 = require("./stateFetchers");
const cacheFile = path_1.default.join(".cache/fork.json");
class ForkCacheService {
    constructor(forkSource) {
        this.forkSource = forkSource;
        this.currentCache = {};
        this.getCacheKey = () => JSON.stringify(this.forkSource);
        this.setNewContractToCache = (address, content) => {
            if (!this.currentCache[this.getCacheKey()]) {
                this.currentCache[this.getCacheKey()] = {};
            }
            this.currentCache[this.getCacheKey()][address] = content;
            fs_extra_1.default.writeJSONSync(cacheFile, this.currentCache);
        };
        fs_extra_1.default.ensureFileSync(cacheFile);
        this.currentCache = fs_extra_1.default.readJSONSync(cacheFile, { throws: false }) || {};
    }
    getContractCache(address) {
        return (this.currentCache[this.getCacheKey()] || {})[address];
    }
}
exports.ForkCacheService = ForkCacheService;
class ForkService {
    constructor(sourceFetcher, preFetchedAccounts) {
        this.sourceFetcher = sourceFetcher;
        this.preFetchedAccounts = preFetchedAccounts;
        this.accountFetcher = address => {
            return this.sourceFetcher.getBocAndCodeHash({
                address: address,
            });
        };
    }
}
exports.ForkService = ForkService;
_a = ForkService;
ForkService.init = async ({ forkSource, forkContractsConfig, }) => {
    const forkCacheService = new ForkCacheService(forkSource);
    const sourceFetcher = forkSource.type === "live"
        ? await stateFetchers_1.LiveFetcher.init(forkSource.connection)
        : new stateFetchers_1.BlockFetcher(forkCacheService, forkSource.block);
    const preFetchedAccounts = forkContractsConfig.length == 0
        ? undefined
        : await (0, rxjs_1.lastValueFrom)((0, rxjs_1.from)(forkContractsConfig).pipe((0, rxjs_1.mergeMap)(({ abi, ...rest }) => (0, rxjs_1.defer)(async () => {
            let abiJson;
            const resolvedPath = path_1.default.resolve(abi.path);
            try {
                abiJson = JSON.parse(fs_extra_1.default.readFileSync(resolvedPath, "utf8"));
            }
            catch (e) {
                console.log("Failed to read abi from path", resolvedPath, e);
            }
            let codeHash;
            if ("address" in rest) {
                codeHash = await sourceFetcher
                    .getBocAndCodeHash({ address: new everscale_inpage_provider_1.Address(rest.address) })
                    .then(res => res.codeHash);
            }
            if ("codeHash" in rest) {
                if (typeof rest.codeHash === "string") {
                    codeHash = rest.codeHash;
                }
                else {
                    codeHash = await sourceFetcher
                        .getBocAndCodeHash({ address: new everscale_inpage_provider_1.Address(rest.codeHash.deriveAddress) })
                        .then(({ codeHash }) => codeHash);
                }
            }
            return {
                abi: abiJson,
                codeHash,
                abiPath: resolvedPath,
                contractName: (0, utils_1.getContractNameFromAbiPath)(abi.path),
            };
        })), (0, rxjs_1.filter)(data => !!data.abi && !!data.codeHash), (0, rxjs_1.toArray)()));
    return new ForkService(sourceFetcher, preFetchedAccounts);
};
