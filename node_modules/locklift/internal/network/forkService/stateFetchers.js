"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockFetcher = exports.LiveFetcher = void 0;
const everscale_inpage_provider_1 = require("everscale-inpage-provider");
const nodejs_1 = require("everscale-standalone-client/nodejs");
const axios_1 = __importDefault(require("axios"));
const logger_1 = require("../../logger");
class LiveFetcher {
    constructor(provider) {
        this.provider = provider;
    }
    async _getBocAndCodeHash({ address }) {
        const { state } = await this.provider.getFullContractState({ address });
        if (!state || !state.codeHash) {
            throw new Error(`Failed to get state for ${address}`);
        }
        return { boc: state.boc, codeHash: state.codeHash, type: "accountStuffBoc" };
    }
    async getBocAndCodeHash(params) {
        return await this._getBocAndCodeHash(params);
    }
}
exports.LiveFetcher = LiveFetcher;
_a = LiveFetcher;
LiveFetcher.init = async (connectionConfig) => {
    const provider = new everscale_inpage_provider_1.ProviderRpcClient({
        fallback: () => nodejs_1.EverscaleStandaloneClient.create({
            connection: connectionConfig,
        }),
    });
    await provider.ensureInitialized();
    return new LiveFetcher(provider);
};
class BlockFetcher {
    constructor(cacheService, blockNumber) {
        this.cacheService = cacheService;
        this.blockNumber = blockNumber;
    }
    async _getBocAndCodeHash({ address }) {
        logger_1.logger.printInfo(`Getting state for ${address.toString()}, it may take a while...`);
        const { data } = await axios_1.default.post(" https://states.everscan.io/apply_mc", {
            account: address.toString(),
            mcSeqno: this.blockNumber,
        });
        if (!data || !data.codeHash) {
            throw new Error(`Failed to get state for ${address}`);
        }
        logger_1.logger.printInfo(`Got state for ${address.toString()}, added to cache`);
        return { boc: data.accountBoc, codeHash: data.codeHash, type: "fullAccountBoc" };
    }
    async getBocAndCodeHash(params) {
        const cached = this.cacheService.getContractCache(params.address.toString());
        if (cached) {
            return cached;
        }
        const newContent = await this._getBocAndCodeHash(params);
        this.cacheService.setNewContractToCache(params.address.toString(), newContent);
        return newContent;
    }
}
exports.BlockFetcher = BlockFetcher;
